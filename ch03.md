# 基本语法

标签（空格分隔）： Yesod-Book

---

学习任何新技术的第一步就是把它运行起来。本章的目标就是让你做一个简单的Yesod应用，涉及到一些基本概念和技术。

# Hello World

我们以一个简单的Hello World 网页开始：
```Haskell
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE QuasiQuotes           #-}
{-# LANGUAGE TemplateHaskell       #-}
{-# LANGUAGE TypeFamilies          #-}
import           Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler Html
getHomeR = defaultLayout [whamlet|Hello World!|]

main :: IO ()
main = warp 3000 HelloWorld
```

代码保存为`helloworld.hs`，执行`runhaskell helloworld.hs`，然后你会在3000端口上运行一个web服务。注意，如果你是根据快速指南，使用`stack`来安装的Yesod，你可能没有安装`runhaskell`，这样你需要使用`stack runghc helloworld.hs`替代。如果你访问[http://localhost:3000](http://localhost:3000, )，你会得到以下HTML：

```HTML
<!DOCTYPE html>
<html><head><title></title></head><body>Hello World!</body></html>
```
本章后面的内容会逐步分析这个例子。

# 路由

与大多数现代web框架一样，Yesod使用前端控制器模式。这就意味着，每个请求都会集中到一个地方，从这里进行路由分发。做一个对比，PHP和ASP之类的，你通常会创建大量不同的文件，然后web服务器会自动将请求映射到相应的文件。

另外，Yesod使用声明样式来指定路由。在我们的例子中，它长这样：
```Haskell
mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]
```
> `mkYesod`是一个Template Haskell函数，`parseRoutes`是一个QuasiQuoter。

用白话描述这句代码就是：在Hello World应用中，创建一个名字叫做`HomeR`的路由，它监听映射到`/`（应用的根）的请求，而且能响应`GET`请求。我们把`HomeR`称作一个资源（Resource），这是最后"R"的来历。
> 对资源命名使用R后缀是只一个惯例，但是大家通常都会遵循这个惯例。因为它让代码更容易读，容易理解。

`mkYesod` TH函数产生了相当多的代码：一个路由数据类型，解析器和渲染器函数，一个分发函数，和一些辅助类型。我们会在路由那一章了解更多细节。现在我们使用`-ddump-splices` GHC选项，可以得到生成的代码，下面是一个整理过的版本：

```Haskell
instance RenderRoute HelloWorld where
    data Route HelloWorld = HomeR
        deriving (Show, Eq, Read)
    renderRoute HomeR = ([], [])

instance ParseRoute HelloWorld where
    parseRoute ([], _) = Just HomeR
    parseRoute _       = Nothing

instance YesodDispatch HelloWorld where
    yesodDispatch env req =
        yesodRunner handler env mroute req
      where
        mroute = parseRoute (pathInfo req, textQueryString req)
        handler =
            case mroute of
                Nothing -> notFound
                Just HomeR ->
                    case requestMethod req of
                        "GET" -> getHomeR
                        _     -> badMethod

type Handler = HandlerT HelloWorld IO
```

> 除了使用`-ddump-splices`，为你的应用生成Haddock文档，查看到底生成了什么数据类型和函数，这个方法也是非常有用的。

我们可以看到`RenderRoute`类定义了一个*绑定数据类型*，它给我们的应用提供了一个路由。这个简单例子中，我们只有一个路由：`HomeR`。在真正的应用中，我们会有更多路由，而且要比我们的`HomeR`复杂的多。

`renderRoute` 将一个路由转换成路径片段和查询参数。再次说明，我们的例子非常简单，所以代码看起来也很简单：所以两个值都是空数组。

`ParseRoute` 提供一个相反的函数，`parseRoute`。 这里我们可以看到我们的使用Template Haskell的目的之一：它保证路由的解析和渲染的正确性。这类代码如果手工写的话，很难将他们保持同步。我们使用代码生成，我们可以让编译器（还有Yesod）为我们处理这些细节。

`YesodDispatch` 提供一个把输入请求传递到相应的处理函数的途径。这个处理过程本质上是：
1. 解析请求
2. 选择一个处理函数
3. 运行处理函数

代码生成会根据一个简单的格式来匹配处理函数的名字，这个我们会在后面介绍。

最后，我们有一个`Handler`的类型别名，使得我们写代码更容易。

我们还有很多东西在这里并没有叙述。生成的分发代码为了效率，其实使用了视图模式语言扩展，这样创建了更多类型类实例，这里还有其他情况处理，比如子站点。随着阅读本书，你会深入了解这些细节，特别是到"理解请求"这一章。

# 处理函数

未完待续





